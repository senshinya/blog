---
title: 3. 数据库系统
date: 2024-08-03T17:43:00+08:00
category: 系统架构设计师
---

### 数据库系统

* 基本特征
  * 数据按一定的数据模型组织、描述和存储
  * 可共享
  * 冗余度较小
  * 数据独立性较高
  * 易扩展
* 数据库系统 DBS 由以下四部分组成
  * 数据库
  * 硬件
  * 软件
  * 人员

### 三级模式-两极映像

 ![三级模式-两极映像](/images/system_architect/ac238a1a-e3fe-455e-9c73-2ed669328372/%E6%88%AA%E5%B1%8F2024-08-03%2018.10.36.png)

* 内模式：管理如何存储物理的数据、对应具体物理存储文件
* 模式：即概念模式，根据应、需求将物理数据划分成一张张表
* 外模式：对应数据库中的视图，将表进行一定处理后再提供给用户
* 外模式-模式映像：表和视图间的映射，存在于概念和外部之间。若表中数据发生修改，只需要修改此映射而无须修改应用程序
* 模式-内模式映像：表和数据的物理存储之间的映射，存在于概念和内部之间，若修改了数据存储方式，只需要修改此映射而无须修改应用程序

### 数据库设计

 ![数据库设计过程](/images/system_architect/381e125c-fc16-4b1a-85e4-e8778997c042/%E6%88%AA%E5%B1%8F2024-08-03%2018.18.42.png)


1. 需求分析。产出数据流图、数据字典、需求说明书。获得用户对系统的三个要求：信息、处理、系统
2. 概念结构设计。包括选择局部应用、逐一设计分 ER 图、ER 图合并。合并时主要存在的冲突有

   
   1. 属性冲突。同一属性存在于不同的 ER 图中
   2. 命名冲突。相同意义的属性在不同的 ER 图上有不同的命名。或名称相同的属性在不同的 ER 图中表示不同的属性
   3. 结构冲突。同一实体在不同的 ER 图中有不同的属性，同一对象在某一 ER 图中被抽象为实体而在另一 ER 图中抽象为属性
3. 逻辑结构设计，将 ER 图转换为关系模式
4. 物理设计，步骤包括确定数据分布、存储和访问方式
5. 数据库实施阶段
6. 数据库运行和维护阶段

### 数据模型

* 关系模型是二维表形式表示的实体-联系模型
* 概念模型是从用户角度进行建模的
* 数据模型三要素：数据结构、数据操作、数据约束条件
* E-R 模型中，使用椭圆表示属性（一般没有）、长方形表示实体、菱形表示联系，联系两端要填写联系类型
* 实体：客观存在且可相互区别的事物。弱实体依赖于强实体而存在
* 属性：实体所具有的特征
* 联系：事物内部及事物之间的联系，在 ER 图中反映为实体内部的联系和实体之间的联系
* 联系类型：1:1、1:N、M:N
* E-R 模型转换为关系模型：每个实体都对应一个关系模式；联系分为三种
  * 1:1 中，联系可以放到任意的两端实体中作为一个属性，也可以转换为一个单独的关系模式
  * 1:N 中，联系可以单独作为一个关系模式，也可以在 N 端加入 1 端实体的主键
  * M:N 中，联系必须作为一个单独的关系模式，其主键是 M 端和 N 端的联合主键

### 关系代数

* 并：结果是两张表中所有记录合并，相同记录只显示一次
* 交：结果是两张表中相同的记录
* 差：S1-S2，结果是 S1 表中有而 S2 表中没有的那些记录
* 笛卡尔积：S1✖️S2，产生的结果包括 S1 和 S2 的所有属性列，且 S1 中每条记录依次和 S2 中所有记录组合成一条记录，最终属性列为 S1 + S2 属性列，记录数为 S1\*S2 记录数
* 投影 **π**：实际是按照条件选择某关系模式中的某列，列也可以用数字表示。使用 SELECT 实现
* 选择 **σ**：实际是按条件选择某关系模式中的某条记录。使用 WHERE 实现
* 自然连接：显示全部的属性列，但是相同属性列只显示一次，显示两个关系模式中属性相同且值相同的记录

 ![自然连接例子](/images/system_architect/e51df1c9-8bdb-4b4c-884c-5c5deb7e078a/%E6%88%AA%E5%B1%8F2024-08-03%2019.17.59.png)

 ![自然连接转笛卡尔积](/images/system_architect/753467ce-54bd-4a77-bed0-0b6366929ce1/%E6%88%AA%E5%B1%8F2024-08-03%2019.22.39.png)

### 函数依赖

* 给定一个 X，能确定一个唯一的 Y，则 X 确定 Y，或 Y 依赖 X
* 函数依赖两种规则：
  * 部分函数依赖：A 可确定 C，（A,B）也可确定 C，（A,B）中的一部分可以确定 C，称为部分函数依赖
  * 传递函数依赖，当 A 和 B 不等价时，A 可确定 B，B 可确定 C，则 A 可确定 C
* 函数依赖公理系统。设关系模式 R<U, F>，U 是关系模式 R 的属性全集，F 是关系模式 R 的一个函数依赖集。则对于该关系模式有以下
  * 自反律：若 Y ⊆ X ⊆ U，则 X → Y 为 F 所逻辑蕴含
  * 增广律：若 X → Y 为 F 所逻辑蕴含，且 Z ⊆ U，则 XZ → YZ 为 F 所逻辑蕴含
  * 传递律：若 X → Y 和 Y → Z 为 F 所逻辑蕴含，则 X → Z 为 F 所逻辑蕴含
  * 合并规则：若 X → Y，X → Z，则 X → YZ 为 F 所逻辑蕴含
  * 伪传定律：若 X → Y，WY → Z，则 XW → Z 为 F 所逻辑蕴涵
  * 分解规则：若 X → Y，Z ⊆ Y，则 X → Z 为 F 所逻辑蕴涵

### 键与约束

* 超键：能唯一标识此表的属性的组合
* 候选键：超键中去掉冗余的属性，剩余的属性就是候选键
* 主键：任选一个候选键，即可作为主键
* 外键：其他表中的主键
* 主属性：候选键内的属性为主属性，其他属性为非主属性
* 实体完整性约束：主键约束，主键值不能为空，也不能重复
* 参照完整性约束：外键约束，外键必须是其他表中已存在的主键的值，或为空
* 用户自定义完整性约束：自定义表达式约束，如年龄范围等

### ==范式==

* 第一范式 1NF：每个分量必须是一个不可分的数据项。不允许有小表存在
* 第二范式 2NF：如果关系 R 属于 1NF，且每个非主属性完全函数依赖于任何一个候选码，则 R 属于 2NF。即表中的每一个非主属性不会依赖复合主键中的某一个列。==消除部分函数依赖==
* 第三范式 3NF：满足 1NF 的基础上，表中不存在非主属性对主属性的传递依赖。==消除传递依赖==
* BC 范式 BCNF，在第三范式的基础上进一步消除==主属性==对于主键的部分函数依赖和传递依赖。在每一种情况下，每一个依赖的左边决定因素都必然包含候选键

 ![BCNF](/images/system_architect/4aa47573-6538-4249-98ce-8bd8ba94ed6f/%E6%88%AA%E5%B1%8F2024-08-04%2012.11.48.png)

* 候选关键字求法：根据依赖集，找出从未在右边出现过的属性，必是候选键之一，以该属性为基础，根据依赖集依次扩展，看能否遍历所有属性，将无法遍历的家如何候选键中

### 模式分解

* 范式间的转换一般是通过拆分属性，即模式分解。一般分为两种
  * 保持函数依赖分解，分解出来的多个关系模式，保持原来依赖集不变。注意需要消除冗余依赖

    
    1. 消除掉冗余依赖后，看函数每个依赖的左右两边属性是否都在同一个分解的模式中
    2. ![](/images/system_architect/d4c03a3b-efb2-47c5-9234-6326f67a804d/%E6%88%AA%E5%B1%8F2024-08-04%2012.31.57.png)
  * 无损分解：分解出的关系模式能够还原出原关系模式。可通过以下定理判断
    * 如果 R 的分解为 p={R1, R2}，F 为 R 所满足的函数依赖集合，分解 p 具有无损连接性的充分必要条件是 R1∩R2→(R1-R2) 或者 R1∩R2→(R2-R1)
    * 当分解为三个及以上关系模式时，可通过表格法

 ![表格法判断无损分解](/images/system_architect/00f9cd7e-54dd-4e82-a3c9-743472d55a45/%E6%88%AA%E5%B1%8F2024-08-04%2012.38.48.png)

### 并发控制

* 事务，由一系列操作组成，要么全做要么全不做
  * 原子性：操作
  * 一致性：数据
  * 隔离性：执行
  * 持续性：改变
* 并发控制存在下面三个问题
  * 丢失更新：两个事务同时操作一个数据导致
  * 不可重复读：读到其他事务在本事务执行期间修改的数据
  * 读脏数据（读未提交）：读到其他事务未提交的数据

### 封锁协议

* X 锁是排他锁（写锁），其他事务无法对该数据进行读写
* S 锁是共享锁（读锁），其他事务只能对该数据加 S 锁
* 共分为三级封锁协议：
  * 一级：修改数据 R 之前加 X 锁，事务结束再释放，解决丢失更新的问题
  * 二级：读数据 R 前加 S 锁，读完后即可释放。解决读脏数据问题
  * 三级：读数据 R 前加 S 锁，事务结束后再释放。解决不可重复读问题

### 数据库安全

* 措施
  * 用户标识和鉴定
  * 存取控制
  * 密码存储和传输
  * 视图保护
  * 审计
* 故障
  * 事务可预期故障：程序中设置 Rollback
  * 事务不可预期故障：如溢出等，DBMS 撤销事务
  * 系统故障
  * 介质故障：日志重做
* 备份：
  * 冷备份
  * 热备份
  * 完全备份
  * 差量备份，完全备份后变化的数据
  * 增量备份，上一次备份后变化的数据
  * 日志文件

### 分布式数据库

* 局部数据库位于不同物理位置，使用全局 DBMS 将所有局部数据库联网管理
* 分片模式：
  * 水平分片：水平的记录
  * 垂直分片：垂直的列值 
* 分布透明性
  * 分片透明：用户/应用程序不需要知道逻辑上访问的表具体是如何分块存储的
  * 位置透明：不需要关系数据物理位置的改变
  * 逻辑透明：不需要知道局部使用的是哪种数据模型
  * 复制透明：不需要关心复制的数据从何而来

### 数据仓库技术

* 面向主题和、集成的、非易失的、随时间变化的数据集合，用与支持管理决策
* ==数据仓库四个层次==
  * 数据源
  * 数据的存储与管理
  * OLAP（联机分析处理）服务器
  * 前端工具
* BI（商业智能）系统包含数据预处理（ETL，抽取、转换、加载）、建立数据仓库、数据分析和数据展现四个阶段

### 反规范化技术

* 牺牲部分规范化来提高性能
* 益处：降低连接操作的需求、降低外键和索引的数目，可能减少表的数目，能够提高查询效率
* 可能的问题：重复存储，可能出现数据完整性问题，降低修改速度
* 方法：
  * 增加冗余列：多个表中保留相同列
  * 增加派生列：增加由本表或者其他表中数据计算生成的列
  * 重新组表：两个表组成一个表减少连接
  * 水平分割表：把数据放到多个独立的表
  * 垂直分割表：将主键和部分列放到一个表

### 大数据

* 大量化、多样化、价值密度低、快速化

### SQL 语言

* 数据库查询 select … from … where
* 分组查询 group by，having 为分组查询附加条件
* 更名运算 as
* 字符串匹配 like
* 数据库插入 insert into … values()
* 数据库删除 delete from … where
* 数据库修改 update … set … where
* 排序 order by 默认升序
* DISTINCT 过滤重复
* UNION：取或运算
* INTERSECT：做与运算